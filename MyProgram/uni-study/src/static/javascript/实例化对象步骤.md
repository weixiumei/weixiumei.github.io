**var a = new F()**
```javascript
  var obj  = {};
  obj.__proto__ = F.prototype;
  F.call(obj);
```
1. 第一行: 我们创建了一个空对象obj;
1. 第二行: 将空对象的__proto__成员指向了F函数对象prototype属性,该原型属性是一个原型对象，也就意味着obj的原型属性上拥有了F.prototype中的属性或方法
1. 第三行: 将F函数对象的this指针替换成obj，然后再调用F函数.obj有了F构造函数中的属性或方法，然后F函数无返回值或返回的不是对象，直接返回obj,否则返回F函数中的对象

**可以理解为 -- 以new操作符调用构造函数的时候，函数内部实际上发生以下变化：**

1. 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
2. 属性和方法被加入到 this 引用的对象中。
3. 新创建的对象由 this 所引用，并且最后隐式的返回 this.
