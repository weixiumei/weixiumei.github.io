![描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8yLzIyLzE3MDZkNThjOTg2Y2ExYWM?x-oss-process=image/format,png)

JavaScript是**单线程**语言,这是因为js是浏览器脚本语言，处理用户交互和操作DOM，多线程会带来类似一个线程删除DOM节点一个在同一个DOM节点上添加内容的复杂问题，所以只有一个调用栈，因此，它按照语句出现的顺序执行的，同一时间只能做一件事

#### v8引擎用于Chrome和node
- 内存堆(Memory Heap)：内存分配发生的地方
- 调用栈(Call Stack)：调用栈是一种数据结构，它记录了我们在程序中的位置。如果我们运行到一个函数，它就会将其放置到栈顶。当从这个函数返回的时候，就会将这个函数从栈顶弹出，这就是调用栈做的事情

注：很多引擎之外的 API，我们把这些称为浏览器提供的 Web API，比如说 DOM、AJAX、setTimeout等等

#### 事件循环Event Loop
+ 为解决页面卡顿，写了同步和异步任务
+ 同步任务进入主线程，异步任务进入Event Table（事件表）并注册函数
+ 当指定的事情完成后，Event Table将这个函数移入Event Queue（事件队列）
    + macro-task(宏任务)：包括整体代码script，setTimeout，setInterval
    + micro-task(微任务)：Promise，process.nextTick
+ 主线程（Call Stack）执行完毕为空，会去将Event Queue里读取所有微任务，进入主线程执行，执行完所有微任务，读取一个宏任务执行，再执行所有微任务...

#### 执行上下文
- 定义：**执行上下文是当前js代码解析和执行代码时运行环境的抽象概念，任何代码执行都是在执行上下文中运行**
- 执行上下文分为 **全局执行上下文** 和 **函数执行上下文**（eval用的少，不考虑）
  - 当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前调用栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的函数执行上下文并压入栈的顶部。
  - 引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。

- 全局执行上下文：一个程序只有一个，不在函数中的代码都位于全局执行上下文，它创建了全局对象window，this指向window
- 函数执行上下文：在函数调用时都会创建一个函数执行上下文，也只能在函数调用时创建
  - 执行上下文生命周期（三个阶段）：**创建 --> 执行 --> 销毁**
  - js是单线程解释执行的脚步语言，在执行之前要先解析代码
  1. 创建（解析）做的事情：
     - **确定this指向(当前的运行环境)**
        + 直接调用： this --> window
        + obj.foo()： this --> obj
        + var aa = new Foo()： this --> aa
        + add.call(obj, 1,2)： this --> obj
        + 箭头函数：this --> 外层的函数的this，若没有外层函数，指向window
        + setTimeout & setInterval 延时函数： this --> window
     - **词法环境**
        + **环境记录器**是存储变量和函数声明的实际位置。
        + **外部环境的引用**意味着它可以访问其父级词法环境（作用域）
     - **变量环境**
        + 也是词法环境，不同的是：词法环境被用来存储函数声明和变量（let 和 const）绑定，而变量环境只用来存储 var 变量绑定。

	**注意**
     1. 在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 undefined（var 情况下），或者未初始化（let 和 const 情况下）
     2. 变量声明提升：这就是为什么你可以在声明之前访问 var 定义的变量（虽然是 undefined），但是在声明之前访问 let 和 const 的变量会得到一个引用错误。
     3. 以下两点是es3，词法环境和变量环境的概念是es5
        1. 创建变量对象-->初始化arguments， 然后提升函数声明和变量声明
        2. 创建作用域链（作用域是变量的可访问性（可见性），由多个执行上下文的变量对象构成的链表叫作用域链）

+ 执行上下文栈：先进后出

	注：
栈和堆 - 栈是一种后进先出的数据结构，那为什么引用值要放在堆中，而原始值要放在栈中。js中有一句话：能量是守衡的，无非是时间换空间，空间换时间的问题。堆比栈大，栈比堆的运算速度快。
